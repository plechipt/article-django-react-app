{"ast":null,"code":"'use strict';\n/*\r\n * merge2\r\n * https://github.com/teambition/merge2\r\n *\r\n * Copyright (c) 2014-2020 Teambition\r\n * Licensed under the MIT license.\r\n */\n\nconst Stream = require('stream');\n\nconst PassThrough = Stream.PassThrough;\nconst slice = Array.prototype.slice;\nmodule.exports = merge2;\n\nfunction merge2() {\n  const streamsQueue = [];\n  const args = slice.call(arguments);\n  let merging = false;\n  let options = args[args.length - 1];\n\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop();\n  } else {\n    options = {};\n  }\n\n  const doEnd = options.end !== false;\n  const doPipeError = options.pipeError === true;\n\n  if (options.objectMode == null) {\n    options.objectMode = true;\n  }\n\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024;\n  }\n\n  const mergedStream = PassThrough(options);\n\n  function addStream() {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options));\n    }\n\n    mergeStream();\n    return this;\n  }\n\n  function mergeStream() {\n    if (merging) {\n      return;\n    }\n\n    merging = true;\n    let streams = streamsQueue.shift();\n\n    if (!streams) {\n      process.nextTick(endStream);\n      return;\n    }\n\n    if (!Array.isArray(streams)) {\n      streams = [streams];\n    }\n\n    let pipesCount = streams.length + 1;\n\n    function next() {\n      if (--pipesCount > 0) {\n        return;\n      }\n\n      merging = false;\n      mergeStream();\n    }\n\n    function pipe(stream) {\n      function onend() {\n        stream.removeListener('merge2UnpipeEnd', onend);\n        stream.removeListener('end', onend);\n\n        if (doPipeError) {\n          stream.removeListener('error', onerror);\n        }\n\n        next();\n      }\n\n      function onerror(err) {\n        mergedStream.emit('error', err);\n      } // skip ended stream\n\n\n      if (stream._readableState.endEmitted) {\n        return next();\n      }\n\n      stream.on('merge2UnpipeEnd', onend);\n      stream.on('end', onend);\n\n      if (doPipeError) {\n        stream.on('error', onerror);\n      }\n\n      stream.pipe(mergedStream, {\n        end: false\n      }); // compatible for old stream\n\n      stream.resume();\n    }\n\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i]);\n    }\n\n    next();\n  }\n\n  function endStream() {\n    merging = false; // emit 'queueDrain' when all streams merged.\n\n    mergedStream.emit('queueDrain');\n\n    if (doEnd) {\n      mergedStream.end();\n    }\n  }\n\n  mergedStream.setMaxListeners(0);\n  mergedStream.add = addStream;\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd');\n  });\n\n  if (args.length) {\n    addStream.apply(null, args);\n  }\n\n  return mergedStream;\n} // check and pause streams for pipe.\n\n\nfunction pauseStreams(streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options));\n    }\n\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.');\n    }\n\n    streams.pause();\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options);\n    }\n  }\n\n  return streams;\n}","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/merge2/index.js"],"names":["Stream","require","PassThrough","slice","Array","prototype","module","exports","merge2","streamsQueue","args","call","arguments","merging","options","length","isArray","pipe","pop","doEnd","end","doPipeError","pipeError","objectMode","highWaterMark","mergedStream","addStream","i","len","push","pauseStreams","mergeStream","streams","shift","process","nextTick","endStream","pipesCount","next","stream","onend","removeListener","onerror","err","emit","_readableState","endEmitted","on","resume","setMaxListeners","add","apply","pause","Error"],"mappings":"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","sourcesContent":["'use strict'\r\n/*\r\n * merge2\r\n * https://github.com/teambition/merge2\r\n *\r\n * Copyright (c) 2014-2020 Teambition\r\n * Licensed under the MIT license.\r\n */\r\nconst Stream = require('stream')\r\nconst PassThrough = Stream.PassThrough\r\nconst slice = Array.prototype.slice\r\n\r\nmodule.exports = merge2\r\n\r\nfunction merge2 () {\r\n  const streamsQueue = []\r\n  const args = slice.call(arguments)\r\n  let merging = false\r\n  let options = args[args.length - 1]\r\n\r\n  if (options && !Array.isArray(options) && options.pipe == null) {\r\n    args.pop()\r\n  } else {\r\n    options = {}\r\n  }\r\n\r\n  const doEnd = options.end !== false\r\n  const doPipeError = options.pipeError === true\r\n  if (options.objectMode == null) {\r\n    options.objectMode = true\r\n  }\r\n  if (options.highWaterMark == null) {\r\n    options.highWaterMark = 64 * 1024\r\n  }\r\n  const mergedStream = PassThrough(options)\r\n\r\n  function addStream () {\r\n    for (let i = 0, len = arguments.length; i < len; i++) {\r\n      streamsQueue.push(pauseStreams(arguments[i], options))\r\n    }\r\n    mergeStream()\r\n    return this\r\n  }\r\n\r\n  function mergeStream () {\r\n    if (merging) {\r\n      return\r\n    }\r\n    merging = true\r\n\r\n    let streams = streamsQueue.shift()\r\n    if (!streams) {\r\n      process.nextTick(endStream)\r\n      return\r\n    }\r\n    if (!Array.isArray(streams)) {\r\n      streams = [streams]\r\n    }\r\n\r\n    let pipesCount = streams.length + 1\r\n\r\n    function next () {\r\n      if (--pipesCount > 0) {\r\n        return\r\n      }\r\n      merging = false\r\n      mergeStream()\r\n    }\r\n\r\n    function pipe (stream) {\r\n      function onend () {\r\n        stream.removeListener('merge2UnpipeEnd', onend)\r\n        stream.removeListener('end', onend)\r\n        if (doPipeError) {\r\n          stream.removeListener('error', onerror)\r\n        }\r\n        next()\r\n      }\r\n      function onerror (err) {\r\n        mergedStream.emit('error', err)\r\n      }\r\n      // skip ended stream\r\n      if (stream._readableState.endEmitted) {\r\n        return next()\r\n      }\r\n\r\n      stream.on('merge2UnpipeEnd', onend)\r\n      stream.on('end', onend)\r\n\r\n      if (doPipeError) {\r\n        stream.on('error', onerror)\r\n      }\r\n\r\n      stream.pipe(mergedStream, { end: false })\r\n      // compatible for old stream\r\n      stream.resume()\r\n    }\r\n\r\n    for (let i = 0; i < streams.length; i++) {\r\n      pipe(streams[i])\r\n    }\r\n\r\n    next()\r\n  }\r\n\r\n  function endStream () {\r\n    merging = false\r\n    // emit 'queueDrain' when all streams merged.\r\n    mergedStream.emit('queueDrain')\r\n    if (doEnd) {\r\n      mergedStream.end()\r\n    }\r\n  }\r\n\r\n  mergedStream.setMaxListeners(0)\r\n  mergedStream.add = addStream\r\n  mergedStream.on('unpipe', function (stream) {\r\n    stream.emit('merge2UnpipeEnd')\r\n  })\r\n\r\n  if (args.length) {\r\n    addStream.apply(null, args)\r\n  }\r\n  return mergedStream\r\n}\r\n\r\n// check and pause streams for pipe.\r\nfunction pauseStreams (streams, options) {\r\n  if (!Array.isArray(streams)) {\r\n    // Backwards-compat with old-style streams\r\n    if (!streams._readableState && streams.pipe) {\r\n      streams = streams.pipe(PassThrough(options))\r\n    }\r\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\r\n      throw new Error('Only readable stream can be merged.')\r\n    }\r\n    streams.pause()\r\n  } else {\r\n    for (let i = 0, len = streams.length; i < len; i++) {\r\n      streams[i] = pauseStreams(streams[i], options)\r\n    }\r\n  }\r\n  return streams\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
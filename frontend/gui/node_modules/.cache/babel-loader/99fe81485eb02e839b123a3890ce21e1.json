{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst matcher_1 = require(\"./matcher\");\n\nclass PartialMatcher extends matcher_1.default {\n  match(filepath) {\n    const parts = filepath.split('/');\n    const levels = parts.length;\n\n    const patterns = this._storage.filter(info => !info.complete || info.segments.length > levels);\n\n    for (const pattern of patterns) {\n      const section = pattern.sections[0];\n      /**\r\n       * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n       * but only if the level has reached the end of the first group.\r\n       *\r\n       * fixtures/{a,b}/**\r\n       *  ^ true/false  ^ always true\r\n      */\n\n      if (!pattern.complete && levels > section.length) {\n        return true;\n      }\n\n      const match = parts.every((part, index) => {\n        const segment = pattern.segments[index];\n\n        if (segment.dynamic && segment.patternRe.test(part)) {\n          return true;\n        }\n\n        if (!segment.dynamic && segment.pattern === part) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (match) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.default = PartialMatcher;","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/@graphql-tools/load/node_modules/fast-glob/out/providers/matchers/partial.js"],"names":["Object","defineProperty","exports","value","matcher_1","require","PartialMatcher","default","match","filepath","parts","split","levels","length","patterns","_storage","filter","info","complete","segments","pattern","section","sections","every","part","index","segment","dynamic","patternRe","test"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,SAAS,GAAGC,OAAO,CAAC,WAAD,CAAzB;;AACA,MAAMC,cAAN,SAA6BF,SAAS,CAACG,OAAvC,CAA+C;AAC3CC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACZ,UAAMC,KAAK,GAAGD,QAAQ,CAACE,KAAT,CAAe,GAAf,CAAd;AACA,UAAMC,MAAM,GAAGF,KAAK,CAACG,MAArB;;AACA,UAAMC,QAAQ,GAAG,KAAKC,QAAL,CAAcC,MAAd,CAAsBC,IAAD,IAAU,CAACA,IAAI,CAACC,QAAN,IAAkBD,IAAI,CAACE,QAAL,CAAcN,MAAd,GAAuBD,MAAxE,CAAjB;;AACA,SAAK,MAAMQ,OAAX,IAAsBN,QAAtB,EAAgC;AAC5B,YAAMO,OAAO,GAAGD,OAAO,CAACE,QAAR,CAAiB,CAAjB,CAAhB;AACA;;;;;;;;AAOA,UAAI,CAACF,OAAO,CAACF,QAAT,IAAqBN,MAAM,GAAGS,OAAO,CAACR,MAA1C,EAAkD;AAC9C,eAAO,IAAP;AACH;;AACD,YAAML,KAAK,GAAGE,KAAK,CAACa,KAAN,CAAY,CAACC,IAAD,EAAOC,KAAP,KAAiB;AACvC,cAAMC,OAAO,GAAGN,OAAO,CAACD,QAAR,CAAiBM,KAAjB,CAAhB;;AACA,YAAIC,OAAO,CAACC,OAAR,IAAmBD,OAAO,CAACE,SAAR,CAAkBC,IAAlB,CAAuBL,IAAvB,CAAvB,EAAqD;AACjD,iBAAO,IAAP;AACH;;AACD,YAAI,CAACE,OAAO,CAACC,OAAT,IAAoBD,OAAO,CAACN,OAAR,KAAoBI,IAA5C,EAAkD;AAC9C,iBAAO,IAAP;AACH;;AACD,eAAO,KAAP;AACH,OATa,CAAd;;AAUA,UAAIhB,KAAJ,EAAW;AACP,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH;;AAhC0C;;AAkC/CN,OAAO,CAACK,OAAR,GAAkBD,cAAlB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst matcher_1 = require(\"./matcher\");\r\nclass PartialMatcher extends matcher_1.default {\r\n    match(filepath) {\r\n        const parts = filepath.split('/');\r\n        const levels = parts.length;\r\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\r\n        for (const pattern of patterns) {\r\n            const section = pattern.sections[0];\r\n            /**\r\n             * In this case, the pattern has a globstar and we must read all directories unconditionally,\r\n             * but only if the level has reached the end of the first group.\r\n             *\r\n             * fixtures/{a,b}/**\r\n             *  ^ true/false  ^ always true\r\n            */\r\n            if (!pattern.complete && levels > section.length) {\r\n                return true;\r\n            }\r\n            const match = parts.every((part, index) => {\r\n                const segment = pattern.segments[index];\r\n                if (segment.dynamic && segment.patternRe.test(part)) {\r\n                    return true;\r\n                }\r\n                if (!segment.dynamic && segment.pattern === part) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (match) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.default = PartialMatcher;\r\n"]},"metadata":{},"sourceType":"script"}
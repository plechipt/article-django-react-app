{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nconst path = require(\"path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst micromatch = require(\"micromatch\");\n\nconst picomatch = require(\"picomatch\");\n\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\n\nfunction isStaticPattern(pattern, options = {}) {\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern, options = {}) {\n  /**\r\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n   * An empty string cannot be a dynamic pattern.\r\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\r\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n   * filepath directly (without read directory).\r\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  let {\n    parts\n  } = picomatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  }));\n  /**\r\n   * The scan method returns an empty array in some cases.\r\n   * See micromatch/picomatch#58 for more details.\r\n   */\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\r\n   * The scan method does not return an empty part for the pattern with a forward slash.\r\n   * This is another part of micromatch/picomatch#58.\r\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/@graphql-tools/load-files/node_modules/fast-glob/out/utils/pattern.js"],"names":["Object","defineProperty","exports","value","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","picomatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSIONS_SYMBOLS_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","parts","scan","assign","length","unshift","map","entry","patternsRe","some","patternRe"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\r\nconst path = require(\"path\");\r\nconst globParent = require(\"glob-parent\");\r\nconst micromatch = require(\"micromatch\");\r\nconst picomatch = require(\"picomatch\");\r\nconst GLOBSTAR = '**';\r\nconst ESCAPE_SYMBOL = '\\\\';\r\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\r\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[.*]/;\r\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\(.*\\|.*\\)/;\r\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\(.*\\)/;\r\nconst BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\\.\\.).*}/;\r\nfunction isStaticPattern(pattern, options = {}) {\r\n    return !isDynamicPattern(pattern, options);\r\n}\r\nexports.isStaticPattern = isStaticPattern;\r\nfunction isDynamicPattern(pattern, options = {}) {\r\n    /**\r\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\r\n     * An empty string cannot be a dynamic pattern.\r\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\r\n     */\r\n    if (pattern === '') {\r\n        return false;\r\n    }\r\n    /**\r\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\r\n     * filepath directly (without read directory).\r\n     */\r\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\r\n        return true;\r\n    }\r\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexports.isDynamicPattern = isDynamicPattern;\r\nfunction convertToPositivePattern(pattern) {\r\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\r\n}\r\nexports.convertToPositivePattern = convertToPositivePattern;\r\nfunction convertToNegativePattern(pattern) {\r\n    return '!' + pattern;\r\n}\r\nexports.convertToNegativePattern = convertToNegativePattern;\r\nfunction isNegativePattern(pattern) {\r\n    return pattern.startsWith('!') && pattern[1] !== '(';\r\n}\r\nexports.isNegativePattern = isNegativePattern;\r\nfunction isPositivePattern(pattern) {\r\n    return !isNegativePattern(pattern);\r\n}\r\nexports.isPositivePattern = isPositivePattern;\r\nfunction getNegativePatterns(patterns) {\r\n    return patterns.filter(isNegativePattern);\r\n}\r\nexports.getNegativePatterns = getNegativePatterns;\r\nfunction getPositivePatterns(patterns) {\r\n    return patterns.filter(isPositivePattern);\r\n}\r\nexports.getPositivePatterns = getPositivePatterns;\r\nfunction getBaseDirectory(pattern) {\r\n    return globParent(pattern, { flipBackslashes: false });\r\n}\r\nexports.getBaseDirectory = getBaseDirectory;\r\nfunction hasGlobStar(pattern) {\r\n    return pattern.includes(GLOBSTAR);\r\n}\r\nexports.hasGlobStar = hasGlobStar;\r\nfunction endsWithSlashGlobStar(pattern) {\r\n    return pattern.endsWith('/' + GLOBSTAR);\r\n}\r\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\r\nfunction isAffectDepthOfReadingPattern(pattern) {\r\n    const basename = path.basename(pattern);\r\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\r\n}\r\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\r\nfunction expandPatternsWithBraceExpansion(patterns) {\r\n    return patterns.reduce((collection, pattern) => {\r\n        return collection.concat(expandBraceExpansion(pattern));\r\n    }, []);\r\n}\r\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\r\nfunction expandBraceExpansion(pattern) {\r\n    return micromatch.braces(pattern, {\r\n        expand: true,\r\n        nodupes: true\r\n    });\r\n}\r\nexports.expandBraceExpansion = expandBraceExpansion;\r\nfunction getPatternParts(pattern, options) {\r\n    let { parts } = picomatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\r\n    /**\r\n     * The scan method returns an empty array in some cases.\r\n     * See micromatch/picomatch#58 for more details.\r\n     */\r\n    if (parts.length === 0) {\r\n        parts = [pattern];\r\n    }\r\n    /**\r\n     * The scan method does not return an empty part for the pattern with a forward slash.\r\n     * This is another part of micromatch/picomatch#58.\r\n     */\r\n    if (parts[0].startsWith('/')) {\r\n        parts[0] = parts[0].slice(1);\r\n        parts.unshift('');\r\n    }\r\n    return parts;\r\n}\r\nexports.getPatternParts = getPatternParts;\r\nfunction makeRe(pattern, options) {\r\n    return micromatch.makeRe(pattern, options);\r\n}\r\nexports.makeRe = makeRe;\r\nfunction convertPatternsToRe(patterns, options) {\r\n    return patterns.map((pattern) => makeRe(pattern, options));\r\n}\r\nexports.convertPatternsToRe = convertPatternsToRe;\r\nfunction matchAny(entry, patternsRe) {\r\n    return patternsRe.some((patternRe) => patternRe.test(entry));\r\n}\r\nexports.matchAny = matchAny;\r\n"]},"metadata":{},"sourceType":"script"}